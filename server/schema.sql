CREATE DATABASE website;
\c website


-- Use UTC-aware timestamps
CREATE EXTENSION IF NOT EXISTS pgcrypto; -- handy later, optional

-- === THOUGHTS ===
CREATE TABLE thoughts (
  id              BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  title           TEXT NOT NULL,
  date_published  TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  body            TEXT NOT NULL,
  likes           INTEGER NOT NULL DEFAULT 0 CHECK (likes >= 0),
  created_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at      TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Comments for thoughts
CREATE TABLE thought_comments (
  id         BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  body       TEXT NOT NULL,
  timestamp  TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  likes      INTEGER NOT NULL DEFAULT 0 CHECK (likes >= 0),
  thought_id BIGINT NOT NULL REFERENCES thoughts(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Helpful indexes
CREATE INDEX idx_thoughts_date_published ON thoughts (date_published DESC);
CREATE INDEX idx_thought_comments_thought_id ON thought_comments (thought_id);

-- === PROJECTS ===
CREATE TABLE projects (
  id         BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  title      TEXT NOT NULL,
  body       TEXT NOT NULL,
  likes      INTEGER NOT NULL DEFAULT 0 CHECK (likes >= 0),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Comments for projects
CREATE TABLE project_comments (
  id         BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  body       TEXT NOT NULL,
  timestamp  TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  likes      INTEGER NOT NULL DEFAULT 0 CHECK (likes >= 0),
  project_id BIGINT NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_project_comments_project_id ON project_comments (project_id);

-- Optional: simple trigger to auto-update updated_at on UPDATE
CREATE OR REPLACE FUNCTION touch_updated_at() RETURNS trigger AS $$
BEGIN
  NEW.updated_at := NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_touch_thoughts
BEFORE UPDATE ON thoughts
FOR EACH ROW EXECUTE FUNCTION touch_updated_at();

CREATE TRIGGER trg_touch_thought_comments
BEFORE UPDATE ON thought_comments
FOR EACH ROW EXECUTE FUNCTION touch_updated_at();

CREATE TRIGGER trg_touch_projects
BEFORE UPDATE ON projects
FOR EACH ROW EXECUTE FUNCTION touch_updated_at();

CREATE TRIGGER trg_touch_project_comments
BEFORE UPDATE ON project_comments
FOR EACH ROW EXECUTE FUNCTION touch_updated_at();

-- Thoughts: increment like and return the new count
UPDATE thoughts
SET likes = likes + 1
WHERE id = $1
RETURNING likes;

-- Thought comment like
UPDATE thought_comments
SET likes = likes + 1
WHERE id = $1
RETURNING likes;

-- Project like
UPDATE projects
SET likes = likes + 1
WHERE id = $1
RETURNING likes;

-- Project comment like
UPDATE project_comments
SET likes = likes + 1
WHERE id = $1
RETURNING likes;

INSERT INTO thoughts (title, body) VALUES ('First thought', 'Hello world!');
INSERT INTO thought_comments (body, thought_id) VALUES ('Nice post', 1);

UPDATE thoughts SET likes = likes + 1 WHERE id = 1 RETURNING likes;
SELECT t.id, t.title, t.likes, c.id AS comment_id, c.likes AS comment_likes
FROM thoughts t
LEFT JOIN thought_comments c ON c.thought_id = t.id
WHERE t.id = 1;