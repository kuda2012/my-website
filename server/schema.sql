-- Use UTC-aware timestamps
CREATE EXTENSION IF NOT EXISTS pgcrypto; -- handy later, optional

-- === THOUGHTS ===
CREATE TABLE IF NOT EXISTS thoughts (
  id              BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  title           TEXT NOT NULL,
  date_published  TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  body            TEXT NOT NULL,
  likes           INTEGER NOT NULL DEFAULT 0 CHECK (likes >= 0),
  created_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at      TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Comments for thoughts
CREATE TABLE IF NOT EXISTS thought_comments (
  id         BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  body       TEXT NOT NULL,
  timestamp  TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  likes      INTEGER NOT NULL DEFAULT 0 CHECK (likes >= 0),
  thought_id BIGINT NOT NULL REFERENCES thoughts(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Helpful indexes
CREATE INDEX IF NOT EXISTS idx_thoughts_date_published ON thoughts (date_published DESC);
CREATE INDEX IF NOT EXISTS idx_thought_comments_thought_id ON thought_comments (thought_id);

-- === PROJECTS ===
CREATE TABLE IF NOT EXISTS projects (
  id         BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  title      TEXT NOT NULL,
  body       TEXT NOT NULL,
  likes      INTEGER NOT NULL DEFAULT 0 CHECK (likes >= 0),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Comments for projects
CREATE TABLE IF NOT EXISTS project_comments (
  id         BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  body       TEXT NOT NULL,
  timestamp  TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  likes      INTEGER NOT NULL DEFAULT 0 CHECK (likes >= 0),
  project_id BIGINT NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS public.about_me (
  id INT PRIMARY KEY,
  content TEXT NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

INSERT INTO public.about_me (id, content)
VALUES (1, 'Write your about me text here')
ON CONFLICT (id) DO NOTHING;
CREATE INDEX IF NOT EXISTS idx_project_comments_project_id ON project_comments (project_id);

-- Optional: simple trigger to auto-update updated_at on UPDATE
CREATE OR REPLACE FUNCTION touch_updated_at() RETURNS trigger AS $$
BEGIN
  NEW.updated_at := NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_touch_thoughts ON thoughts;
CREATE TRIGGER trg_touch_thoughts
BEFORE UPDATE ON thoughts
FOR EACH ROW EXECUTE FUNCTION touch_updated_at();

DROP TRIGGER IF EXISTS trg_touch_thought_comments ON thought_comments;
CREATE TRIGGER trg_touch_thought_comments
BEFORE UPDATE ON thought_comments
FOR EACH ROW EXECUTE FUNCTION touch_updated_at();

DROP TRIGGER IF EXISTS trg_touch_projects ON projects;
CREATE TRIGGER trg_touch_projects
BEFORE UPDATE ON projects
FOR EACH ROW EXECUTE FUNCTION touch_updated_at();

DROP TRIGGER IF EXISTS trg_touch_project_comments ON project_comments;
CREATE TRIGGER trg_touch_project_comments
BEFORE UPDATE ON project_comments
FOR EACH ROW EXECUTE FUNCTION touch_updated_at();

INSERT INTO thoughts (title, body) VALUES ('First thought', 'Hello world!') ON CONFLICT DO NOTHING;
INSERT INTO thought_comments (body, thought_id) VALUES ('Nice post', 1) ON CONFLICT DO NOTHING;

UPDATE thoughts SET likes = likes + 1 WHERE id = 1 RETURNING likes;
SELECT t.id, t.title, t.likes, c.id AS comment_id, c.likes AS comment_likes
FROM thoughts t
LEFT JOIN thought_comments c ON c.thought_id = t.id
WHERE t.id = 1;

-- Create a simple append-only table for stock prices
CREATE TABLE IF NOT EXISTS stock_prices (
  id          BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  symbol      TEXT NOT NULL DEFAULT 'KDM',
  price       NUMERIC(6,2) NOT NULL CHECK (price >= 0),
  created_at  TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Helpful index for “latest price” queries
CREATE INDEX IF NOT EXISTS idx_stock_prices_created_at
  ON stock_prices (created_at DESC);

-- Optional: fastest way to read latest value
-- CREATE VIEW latest_stock_price AS
-- SELECT DISTINCT ON (symbol) symbol, price, created_at
-- FROM stock_prices
-- ORDER BY symbol, created_at DESC;